
{
  "name": "S::new",
  "safe": true,
  "callees": [],
  "adts": {
    "S": [
      "Plain"
    ],
    "std::string::String": [
      "Plain"
    ]
  },
  "span": "$DIR/struct-methods.rs:13:5: 15:6",
  "src": "fn new(s: String) -> S {/n        S { s }/n    }",
  "mir": "fn S::new(_1: std::string::String) -> S {/n    let mut _0: S;/n    debug s => _1;/n    bb0: {/n        _0 = S(_1);/n        return;/n    }/n}/n",
  "doc": ""
}

{
  "name": "S::s_ref",
  "safe": true,
  "callees": [],
  "adts": {
    "S": [
      "Ref"
    ]
  },
  "span": "$DIR/struct-methods.rs:17:5: 17:23",
  "src": "fn s_ref(&self) {}",
  "mir": "fn S::s_ref(_1: &S) -> () {/n    let mut _0: ();/n    debug self => _1;/n    bb0: {/n        return;/n    }/n}/n",
  "doc": ""
}

{
  "name": "S::s_mut_ref",
  "safe": true,
  "callees": [],
  "adts": {
    "S": [
      "MutRef"
    ]
  },
  "span": "$DIR/struct-methods.rs:19:5: 19:31",
  "src": "fn s_mut_ref(&mut self) {}",
  "mir": "fn S::s_mut_ref(_1: &mut S) -> () {/n    let mut _0: ();/n    debug self => _1;/n    bb0: {/n        return;/n    }/n}/n",
  "doc": ""
}

{
  "name": "S::field_ref",
  "safe": true,
  "callees": [],
  "adts": {
    "S": [
      "Ref"
    ]
  },
  "span": "$DIR/struct-methods.rs:21:5: 23:6",
  "src": "fn field_ref(&self) {/n        _ = &self.s;/n    }",
  "mir": "fn S::field_ref(_1: &S) -> () {/n    let mut _0: ();/n    debug self => _1;/n    bb0: {/n        return;/n    }/n}/n",
  "doc": ""
}

{
  "name": "S::field_mut_ref",
  "safe": true,
  "callees": [],
  "adts": {
    "S": [
      "MutRef"
    ]
  },
  "span": "$DIR/struct-methods.rs:25:5: 27:6",
  "src": "fn field_mut_ref(&mut self) {/n        _ = &mut self.s;/n    }",
  "mir": "fn S::field_mut_ref(_1: &mut S) -> () {/n    let mut _0: ();/n    debug self => _1;/n    bb0: {/n        return;/n    }/n}/n",
  "doc": ""
}

{
  "name": "S::write_field",
  "safe": true,
  "callees": [
    "std::string::String::new"
  ],
  "adts": {
    "std::string::String": [
      "Plain"
    ],
    "S": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ]
  },
  "span": "$DIR/struct-methods.rs:30:5: 32:6",
  "src": "fn write_field(&mut self) {/n        self.s = String::new();/n    }",
  "mir": "fn S::write_field(_1: &mut S) -> () {/n    let mut _0: ();/n    let mut _2: std::string::String;/n    debug self => _1;/n    bb0: {/n        _2 = std::string::String::new() -> [return: bb1, unwind continue];/n    }/n    bb1: {/n        drop(((*_1).0: std::string::String)) -> [return: bb2, unwind: bb3];/n    }/n    bb2: {/n        ((*_1).0: std::string::String) = move _2;/n        return;/n    }/n    bb3: {/n        ((*_1).0: std::string::String) = move _2;/n        resume;/n    }/n}/n",
  "doc": " Update the field."
}

{
  "name": "S",
  "constructors": [
    "S::new"
  ],
  "access_self_as_arg": {
    "read": [
      "S::s_ref",
      "S::field_ref"
    ],
    "write": [
      "S::s_mut_ref",
      "S::field_mut_ref",
      "S::write_field"
    ],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "S::new"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [
        "S::write_field"
      ],
      "other": []
    }
  ],
  "span": "$DIR/struct-methods.rs:7:1: 7:9",
  "src": "struct S",
  "docs": [
    " First line. Second line. Forth line.",
    " Field comments."
  ]
}

{
  "name": "std::string::String",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": [
      "S::new"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "S::write_field"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$SYSROOT/alloc/src/string.rs:353:1: 353:18",
  "src": "pub struct String",
  "docs": [
    " A UTF-8â€“encoded, growable string. `String` is the most common string type. It has ownership over the contents of the string, stored in a heap-allocated buffer (see [Representation](#representation)). It is closely related to its borrowed counterpart, the primitive [`str`]. # Examples You can create a `String` from [a literal string][`&str`] with [`String::from`]: [`String::from`]: From::from ``` let hello = String::from(/"Hello, world!/"); ``` You can append a [`char`] to a `String` with the [`push`] method, and append a [`&str`] with the [`push_str`] method: ``` let mut hello = String::from(/"Hello, /"); hello.push('w'); hello.push_str(/"orld!/"); ``` [`push`]: String::push [`push_str`]: String::push_str If you have a vector of UTF-8 bytes, you can create a `String` from it with the [`from_utf8`] method: ``` // some bytes, in a vector let sparkle_heart = vec![240, 159, 146, 150]; // We know these bytes are valid, so we'll use `unwrap()`. let sparkle_heart = String::from_utf8(sparkle_heart).unwrap(); assert_eq!(/"ðŸ’–/", sparkle_heart); ``` [`from_utf8`]: String::from_utf8 # UTF-8 `String`s are always valid UTF-8. If you need a non-UTF-8 string, consider [`OsString`]. It is similar, but without the UTF-8 constraint. Because UTF-8 is a variable width encoding, `String`s are typically smaller than an array of the same `char`s: ``` // `s` is ASCII which represents each `char` as one byte let s = /"hello/"; assert_eq!(s.len(), 5); // A `char` array with the same contents would be longer because // every `char` is four bytes let s = ['h', 'e', 'l', 'l', 'o']; let size: usize = s.into_iter().map(|c| size_of_val(&c)).sum(); assert_eq!(size, 20); // However, for non-ASCII strings, the difference will be smaller // and sometimes they are the same let s = /"ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–/"; assert_eq!(s.len(), 20); let s = ['ðŸ’–', 'ðŸ’–', 'ðŸ’–', 'ðŸ’–', 'ðŸ’–']; let size: usize = s.into_iter().map(|c| size_of_val(&c)).sum(); assert_eq!(size, 20); ``` This raises interesting questions as to how `s[i]` should work. What should `i` be here? Several options include byte indices and `char` indices but, because of UTF-8 encoding, only byte indices would provide constant time indexing. Getting the `i`th `char`, for example, is available using [`chars`]: ``` let s = /"hello/"; let third_character = s.chars().nth(2); assert_eq!(third_character, Some('l')); let s = /"ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–/"; let third_character = s.chars().nth(2); assert_eq!(third_character, Some('ðŸ’–')); ``` Next, what should `s[i]` return? Because indexing returns a reference to underlying data it could be `&u8`, `&[u8]`, or something similar. Since we're only providing one index, `&u8` makes the most sense but that might not be what the user expects and can be explicitly achieved with [`as_bytes()`]: ``` // The first byte is 104 - the byte value of `'h'` let s = /"hello/"; assert_eq!(s.as_bytes()[0], 104); // or assert_eq!(s.as_bytes()[0], b'h'); // The first byte is 240 which isn't obviously useful let s = /"ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–/"; assert_eq!(s.as_bytes()[0], 240); ``` Due to these ambiguities/restrictions, indexing with a `usize` is simply forbidden: ```compile_fail,E0277 let s = /"hello/"; // The following will not compile! println!(/"The first letter of s is {}/", s[0]); ``` It is more clear, however, how `&s[i..j]` should work (that is, indexing with a range). It should accept byte indices (to be constant-time) and return a `&str` which is UTF-8 encoded. This is also called /"string slicing/". Note this will panic if the byte indices provided are not character boundaries - see [`is_char_boundary`] for more details. See the implementations for [`SliceIndex<str>`] for more details on string slicing. For a non-panicking version of string slicing, see [`get`]. [`OsString`]: ../../std/ffi/struct.OsString.html /"ffi::OsString/" [`SliceIndex<str>`]: core::slice::SliceIndex [`as_bytes()`]: str::as_bytes [`get`]: str::get [`is_char_boundary`]: str::is_char_boundary The [`bytes`] and [`chars`] methods return iterators over the bytes and codepoints of the string, respectively. To iterate over codepoints along with byte indices, use [`char_indices`]. [`bytes`]: str::bytes [`chars`]: str::chars [`char_indices`]: str::char_indices # Deref `String` implements <code>[Deref]<Target = [str]></code>, and so inherits all of [`str`]'s methods. In addition, this means that you can pass a `String` to a function which takes a [`&str`] by using an ampersand (`&`): ``` fn takes_str(s: &str) { } let s = String::from(/"Hello/"); takes_str(&s); ``` This will create a [`&str`] from the `String` and pass it in. This conversion is very inexpensive, and so generally, functions will accept [`&str`]s as arguments unless they need a `String` for some specific reason. In certain cases Rust doesn't have enough information to make this conversion, known as [`Deref`] coercion. In the following example a string slice [`&'a str`][`&str`] implements the trait `TraitExample`, and the function `example_func` takes anything that implements the trait. In this case Rust would need to make two implicit conversions, which Rust doesn't have the means to do. For that reason, the following example will not compile. ```compile_fail,E0277 trait TraitExample {} impl<'a> TraitExample for &'a str {} fn example_func<A: TraitExample>(example_arg: A) {} let example_string = String::from(/"example_string/"); example_func(&example_string); ``` There are two options that would work instead. The first would be to change the line `example_func(&example_string);` to `example_func(example_string.as_str());`, using the method [`as_str()`] to explicitly extract the string slice containing the string. The second way changes `example_func(&example_string);` to `example_func(&*example_string);`. In this case we are dereferencing a `String` to a [`str`], then referencing the [`str`] back to [`&str`]. The second way is more idiomatic, however both work to do the conversion explicitly rather than relying on the implicit conversion. # Representation A `String` is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to the internal buffer which `String` uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity. This buffer is always stored on the heap. You can look at these with the [`as_ptr`], [`len`], and [`capacity`] methods: ``` let story = String::from(/"Once upon a time.../"); // Deconstruct the String into parts. let (ptr, len, capacity) = story.into_raw_parts(); // story has nineteen bytes assert_eq!(19, len); // We can re-build a String out of ptr, len, and capacity. This is all // unsafe because we are responsible for making sure the components are // valid: let s = unsafe { String::from_raw_parts(ptr, len, capacity) } ; assert_eq!(String::from(/"Once upon a time.../"), s); ``` [`as_ptr`]: str::as_ptr [`len`]: String::len [`capacity`]: String::capacity If a `String` has enough capacity, adding elements to it will not re-allocate. For example, consider this program: ``` let mut s = String::new(); println!(/"{}/", s.capacity()); for _ in 0..5 {     s.push_str(/"hello/");     println!(/"{}/", s.capacity()); } ``` This will output the following: ```text 0 8 16 16 32 32 ``` At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the [`with_capacity`] method to allocate the correct capacity initially: ``` let mut s = String::with_capacity(25); println!(/"{}/", s.capacity()); for _ in 0..5 {     s.push_str(/"hello/");     println!(/"{}/", s.capacity()); } ``` [`with_capacity`]: String::with_capacity We end up with a different output: ```text 25 25 25 25 25 25 ``` Here, there's no need to allocate more memory inside the loop. [str]: prim@str /"str/" [`str`]: prim@str /"str/" [`&str`]: prim@str /"&str/" [Deref]: core::ops::Deref /"ops::Deref/" [`Deref`]: core::ops::Deref /"ops::Deref/" [`as_str()`]: String::as_str",
    ""
  ]
}
